	‚Ä¢	add_library(dataframe STATIC ${{SOURCE_FILES}})
üîπ This creates a static library named libdataframe.a (or dataframe.lib on Windows). The name libdataframe.a 
is because you named your static library "dataframe". It's naming convention is lib<library_name>.a
üîπ The library consists of all .cpp files in the src/ folder.
üîπ You don‚Äôt need a dataframe folder or file‚Äîit‚Äôs just a name for the compiled output.

	‚Ä¢	target_include_directories(dataframe PUBLIC include)
üîπ This tells CMake that the header files are in the include/ folder.
üîπ If your .h files are in include/, this line ensures they are accessible in other projects.
üîπ Tells CMake where to find the header files (.h files) for newly created static library "dataframe".
üîπ What This Does:
	‚Ä¢	Any file that links to dataframe will automatically get access to headers in include/.
	‚Ä¢	This allows main.cpp (or other projects) that has a link to your "dataframe" static library to simply #include "dataframe.h" without specifying paths manually.
  so you can see this line target_include_directories(dataframe PUBLIC include) is very important

	‚Ä¢	target_link_libraries(dataframe "${TORCH_LIBRARIES}")
üîπ This links Libtorch to dataframe so it can use PyTorch operations.

‚Ä¢ set(CMAKE_CXX_STANDARD 20)
‚Ä¢ set(CMAKE_CXX_STANDARD_REQUIRED ON)

This will:
	üîπ	Enable C++20 features for your code.
	üîπ	Still allow linking with Libtorch (built with C++17). So the second line ensures that the 
  standard required by torch which is C++17 is still "ON" even though our current project's standard
  is C++20

Libtorch binaries are built using C++17 ABI. If your compiler defaults to a C++20 ABI, you might see linker errors.
‚úÖ Fix: Ensure the ABI setting is correct by doing this.
‚Ä¢ add_definitions(-D_GLIBCXX_USE_CXX11_ABI=0)  # If Libtorch was built with this setting(or ABI=1) depending on what torch was built with


# Add an executable target for testing
‚Ä¢ add_executable(datalib src/main.cpp)  this creates an executable named "datalib" and links it to the "main.cpp" file.
so when you do ./datalib, it will run the main.cpp file inside your src folder

If you replace:
add_executable(datalib main.cpp)
with 
add_executable(${PROJECT_NAME} ${SOURCE_FILES}), like you have done apriori,
It won‚Äôt work correctly, because:
	1.	${PROJECT_NAME} expands to datalib, which is fine.
	2.	${SOURCE_FILES} contains ALL .cpp files, including src/*.cpp, but we only need main.cpp here.
	3.	This would try to compile all .cpp files as an executable, instead of linking them correctly.
  4. Only files with int main() should be executable, and not all .cpp files have int main() so it's not wise to attempt to compile all .cpp as
  executables, and that is what add_executable(${PROJECT_NAME} ${SOURCE_FILES}) tries to do.
So maybe you can rather do
add_executable(${PROJECT_NAME} sr/main.cpp), but a potential downside is that if you have other .cpp files that also
have int main() and they execute other things, then there might be ambiguity if you do ./datalib as cmake wouldn't know which .cpp file to run

In summary, the most optimal approach is
‚Ä¢ add_executable(datalib main.cpp)

This ensures that:
	‚Ä¢	The executable only compiles main.cpp.
	‚Ä¢	The rest of the .cpp files logic is compiled inside libdataframe.a (static library).
  ‚Ä¢ There is no ambiguity if another .cpp file with int main() is to be an executable, because it will have it's own name to
  like so: add_executable(other_name other_file_with_int_main.cpp)
  ‚Ä¢ All executables(like main.cpp, or a .cpp file which is meant for executable duties) must have a int main(){} function.
     Otherwise, the compiler will fail because it won‚Äôt know where to start execution.
‚úÖ KEY TAKEAWAY
When you run "make", it will first compile all  source files (src/*.cpp) into libdataframe.a because of:
add_library(dataframe STATIC ${SOURCE_FILES})

Then it compiles main.cpp separately to build the executable "datalib", because of:
add_executable(datalib main.cpp)

‚úÖ It only compiles the full DataFrame(.cpp files and header files) code once (to libdataframe.a).
‚úÖ When building datalib, it does NOT recompile those .cpp files ‚Äî it just links them.

# Link the dataframe library to the executable
‚Ä¢ target_link_libraries(datalib PRIVATE dataframe)
This line tells CMake to link the executable (datalib) with the dataframe library:
	‚Ä¢	datalib ‚Üí The executable target (from add_executable(datalib main.cpp)).
	‚Ä¢	dataframe ‚Üí The static library that we defined earlier:

üìå 3Ô∏è‚É£ Why PRIVATE vs PUBLIC vs INTERFACE?
Keyword	                      Meaning
PRIVATE	              dataframe is only used by datalib, and not inherited by targets that depend on datalib.
PUBLIC	              dataframe is used by datalib and any target that links to datalib.
INTERFACE	            dataframe is not compiled into datalib but only its include directories and definitions are passed.

For our case 

‚úÖ PRIVATE is correct because:
	‚Ä¢	dataframe (our static library) is only needed by datalib.
	‚Ä¢	Other projects linking to datalib don‚Äôt need to know about dataframe.

üîπ When Would PUBLIC Be Used?

If datalib were another library and other projects depended on it, then we‚Äôd use:
‚Ä¢ target_link_libraries(datalib PUBLIC dataframe)

This way, everything that links to datalib also links to dataframe automatically.
But datalib is not even a library, it's an executable, so no need for PUBLIC there.
